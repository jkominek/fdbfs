Overall key scheme:

\xff space is banned everywhere, so that we can always increment the final
byte to produce the end of a subspace range, without having to worry about
rollover.

=== inodes ===
prefix 'i' inode              -> contains basic attrs and symlink info

prefix 'i' inode \x00 pid1, anything -> info on a lock
prefix 'i' inode \x00 pid2, anything -> info on a lock
prefix 'i' inode \x01 pid1    -> per fuse-process use counter (64 bit LE)
prefix 'i' inode \x01 pid2    -> per fuse-process use counter (64 bit LE)
prefix 'i' inode \x02 xattr0  -> arbitrary number of extended attributes
prefix 'i' inode \x02 xattr1
prefix 'i' inode \x02 xattr2
prefix 'i' inode \xfe inodeattr -> pseudo keys to indicate inode updates
prefix 'd' inode filenameA-> dirents.
prefix 'd' inode filenameB
prefix 'd' inode filenameC
prefix 'f' inode offset0 -> plain block, may be shorter than blocksize if ends in nulls
                             -> totally null blocks can be omitted
prefix 'f' inode offset2 'z'\x01\x00 -> block compressed with whatever algorithm is assigned to \x00
prefix 'f' inode offset3 'p'\x02\x00... -> key contains 512 bytes of parity for the block 
    there should be only one kv pair within a given offset(n) to offset(n+1)
    range.
prefix 'p' pid -> ProcessTableEntry


The \x00 space for locks is adjacent to the inodes, because in a mandatory
locking system, you'd need to read them along with the inode. So we'll
store them for a single range read.

\x01 space is for the use records. The value is an integer counter ('generation')
shared across the process. Currently it's set with FDB_MUTATION_TYPE_MAX, and
removed with FDB_MUTATION_TYPE_COMPARE_AND_CLEAR.

The \xfe space is to register common partial updates to an inode. For
instance, when reading blocks with noatime, the only thing you need to
know about an inode is existance and the size of it. So read the inode
without a read conflict range, but lay down a read conflict on the
inode size key. Anything changing the size will read/write conflict the
inode, and write conflict the inode size key. So another process only
changing the owner (which will read/write the inode, and write conflict
the inode owner attr) won't conflict all of the ongoing reads.

=== garbage ===
prefix 'g' inode -> indicates that nlinks in the inode has gone to zero,
                    and it should be check periodically for all of the
		    usage to have gone to zero, at which time it can be
		    cleared.

=== pid table ===
prefix 'pl' pid1  -> status of a given fuse process
prefix 'pl' pid2

the status should include an incrementing counter as a heartbeat,
and some host information. each process should update its heartbeat
every reasonable timeout amount of time. (30-60 seconds?)

if processes notice that another pid's entry has stopped updating,
they should delete it. the GC process can confirm the liveness of
all pids it encounters when cleaning up inodes.

similarly processes should watch for updates on their pid entry.
if it is updated or erased, they should react immediately.

=== op log ===
prefix 'o' pid opid -> OpLogRecord

Where:
* pid is the same 128-bit process id used in inode-use records.
* opid is a per-process monotonically increasing 64-bit integer (BE in key).
* value is a protobuf OpLogRecord carrying a oneof result payload
  (entry/attr/open/write/etc) to reconstruct and replay a successful
  FUSE reply after uncertain commit.

Subspaces:
* all oplog records for pid P: [ 'o'+P, successor('o'+P) )
* one oplog record:            'o'+P+opid

Runtime tracking (in-memory):
* keep ordered sets of local opids: live, dead.
* when dead has a range strictly below live, clear that whole key range.
* when a pid is classified dead, liveness cleanup can clear its entire
  oplog subspace in a single range clear.

=== meta ===
prefix 'M' -> metadata block. filesystem version and blocksize?


inode record
* INodeRecord
* any information necessary for non-file/non-directory things
* contents mutable
* definitely not portable

directory entry
* DirectoryEntry protobuf message
* inode value
* (struct stat).st_mode & S_IFMT
* contents are immutable
* may not be portable
